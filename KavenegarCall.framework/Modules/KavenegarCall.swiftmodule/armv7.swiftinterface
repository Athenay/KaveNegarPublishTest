// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.1.2 (swiftlang-1100.0.278 clang-1100.0.33.9)
// swift-module-flags: -target armv7-apple-ios10.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name KavenegarCall
import AVFoundation
import CommonCrypto
import CoreFoundation
import Foundation
@_exported import KavenegarCall
import Security
import Swift
import UIKit
import WebRTC
import zlib
public enum SoundType {
  case busy
  case sonar
  case ringing
  case connected
  case end
  public static func == (a: KavenegarCall.SoundType, b: KavenegarCall.SoundType) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public class AudioManeger {
  public init()
  public func playSound(soundName: Swift.String, type: KavenegarCall.SoundType)
  public func stop()
  public var isSpeakerEnabled: Swift.Bool {
    get
    set(value)
  }
  public func configureAudioSession()
  @objc deinit
}
public enum EndpointRole : Swift.String {
  case caller
  case receptor
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public class PeerConnectionStateChangedEvent {
  final public let oldState: WebRTC.RTCIceConnectionState
  final public let newState: WebRTC.RTCIceConnectionState
  @objc deinit
}
public protocol CallDelegate {
  func onCallStateChanged(state: KavenegarCall.CallStatus, isLocalChange: Swift.Bool)
  func onCallFinished(reason: KavenegarCall.CallFinishedReason)
  func onMediaStateChanged(event: KavenegarCall.MediaStateChangedEvent)
}
@objc public class PeerConnectionWrapper : ObjectiveC.NSObject {
  public var onStateChanged: ((KavenegarCall.PeerConnectionStateChangedEvent) -> Swift.Void)?
  public var isMuted: Swift.Bool {
    get
    set(newValue)
  }
  @objc deinit
}
extension PeerConnectionWrapper : WebRTC.RTCPeerConnectionDelegate {
  @objc dynamic public func peerConnection(_ peerConnection: WebRTC.RTCPeerConnection, didChange stateChanged: WebRTC.RTCSignalingState)
  @objc dynamic public func peerConnection(_ peerConnection: WebRTC.RTCPeerConnection, didAdd stream: WebRTC.RTCMediaStream)
  @objc dynamic public func peerConnection(_ peerConnection: WebRTC.RTCPeerConnection, didRemove stream: WebRTC.RTCMediaStream)
  @objc dynamic public func peerConnectionShouldNegotiate(_ peerConnection: WebRTC.RTCPeerConnection)
  @objc dynamic public func peerConnection(_ peerConnection: WebRTC.RTCPeerConnection, didChange newState: WebRTC.RTCIceConnectionState)
  @objc dynamic public func peerConnection(_ peerConnection: WebRTC.RTCPeerConnection, didChange newState: WebRTC.RTCIceGatheringState)
  @objc dynamic public func peerConnection(_ peerConnection: WebRTC.RTCPeerConnection, didGenerate candidate: WebRTC.RTCIceCandidate)
  @objc dynamic public func peerConnection(_ peerConnection: WebRTC.RTCPeerConnection, didRemove candidates: [WebRTC.RTCIceCandidate])
  @objc dynamic public func peerConnection(_ peerConnection: WebRTC.RTCPeerConnection, didOpen dataChannel: WebRTC.RTCDataChannel)
}
extension RTCIceConnectionState {
  public var description: Swift.String {
    get
  }
}
public enum CallDirection : Swift.String {
  case inbound
  case outbound
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public let WebsocketDidConnectNotification: Swift.String
public let WebsocketDidDisconnectNotification: Swift.String
public let WebsocketDisconnectionErrorKeyName: Swift.String
public enum CloseCode : Swift.UInt16 {
  case normal
  case goingAway
  case protocolError
  case protocolUnhandledType
  case noStatusReceived
  case encoding
  case policyViolated
  case messageTooBig
  public typealias RawValue = Swift.UInt16
  public init?(rawValue: Swift.UInt16)
  public var rawValue: Swift.UInt16 {
    get
  }
}
public enum ErrorType : Swift.Error {
  case outputStreamWriteError
  case compressionError
  case invalidSSLError
  case writeTimeoutError
  case protocolError
  case upgradeError
  case closeError
  public static func == (a: KavenegarCall.ErrorType, b: KavenegarCall.ErrorType) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public struct WSError : Swift.Error {
  public let type: KavenegarCall.ErrorType
  public let message: Swift.String
  public let code: Swift.Int
}
public protocol WebSocketClient : AnyObject {
  var delegate: KavenegarCall.WebSocketDelegate? { get set }
  var pongDelegate: KavenegarCall.WebSocketPongDelegate? { get set }
  var disableSSLCertValidation: Swift.Bool { get set }
  var overrideTrustHostname: Swift.Bool { get set }
  var desiredTrustHostname: Swift.String? { get set }
  var sslClientCertificate: KavenegarCall.SSLClientCertificate? { get set }
  var security: KavenegarCall.SSLTrustValidator? { get set }
  var enabledSSLCipherSuites: [Security.SSLCipherSuite]? { get set }
  var isConnected: Swift.Bool { get }
  func connect()
  func disconnect(forceTimeout: Foundation.TimeInterval?, closeCode: Swift.UInt16)
  func write(string: Swift.String, completion: (() -> ())?)
  func write(data: Foundation.Data, completion: (() -> ())?)
  func write(ping: Foundation.Data, completion: (() -> ())?)
  func write(pong: Foundation.Data, completion: (() -> ())?)
}
extension WebSocketClient {
  public func write(string: Swift.String)
  public func write(data: Foundation.Data)
  public func write(ping: Foundation.Data)
  public func write(pong: Foundation.Data)
  public func disconnect()
}
public struct SSLSettings {
  public let useSSL: Swift.Bool
  public let disableCertValidation: Swift.Bool
  public var overrideTrustHostname: Swift.Bool
  public var desiredTrustHostname: Swift.String?
  public let sslClientCertificate: KavenegarCall.SSLClientCertificate?
  public let cipherSuites: [Security.SSLCipherSuite]?
}
public protocol WSStreamDelegate : AnyObject {
  func newBytesInStream()
  func streamDidError(error: Swift.Error?)
}
public protocol WSStream {
  var delegate: KavenegarCall.WSStreamDelegate? { get set }
  func connect(url: Foundation.URL, port: Swift.Int, timeout: Foundation.TimeInterval, ssl: KavenegarCall.SSLSettings, completion: @escaping ((Swift.Error?) -> Swift.Void))
  func write(data: Foundation.Data) -> Swift.Int
  func read() -> Foundation.Data?
  func cleanup()
  func sslTrust() -> (trust: Security.SecTrust?, domain: Swift.String?)
}
@objc open class FoundationStream : ObjectiveC.NSObject, KavenegarCall.WSStream, Foundation.StreamDelegate {
  weak public var delegate: KavenegarCall.WSStreamDelegate?
  public var enableSOCKSProxy: Swift.Bool
  public func connect(url: Foundation.URL, port: Swift.Int, timeout: Foundation.TimeInterval, ssl: KavenegarCall.SSLSettings, completion: @escaping ((Swift.Error?) -> Swift.Void))
  public func write(data: Foundation.Data) -> Swift.Int
  public func read() -> Foundation.Data?
  public func cleanup()
  public func sslTrust() -> (trust: Security.SecTrust?, domain: Swift.String?)
  @objc open func stream(_ aStream: Foundation.Stream, handle eventCode: Foundation.Stream.Event)
  @objc override dynamic public init()
  @objc deinit
}
public protocol WebSocketDelegate : AnyObject {
  func websocketDidConnect(socket: KavenegarCall.WebSocketClient)
  func websocketDidDisconnect(socket: KavenegarCall.WebSocketClient, error: Swift.Error?)
  func websocketDidReceiveMessage(socket: KavenegarCall.WebSocketClient, text: Swift.String)
  func websocketDidReceiveData(socket: KavenegarCall.WebSocketClient, data: Foundation.Data)
}
public protocol WebSocketPongDelegate : AnyObject {
  func websocketDidReceivePong(socket: KavenegarCall.WebSocketClient, data: Foundation.Data?)
}
public protocol WebSocketAdvancedDelegate : AnyObject {
  func websocketDidConnect(socket: KavenegarCall.WebSocket)
  func websocketDidDisconnect(socket: KavenegarCall.WebSocket, error: Swift.Error?)
  func websocketDidReceiveMessage(socket: KavenegarCall.WebSocket, text: Swift.String, response: KavenegarCall.WebSocket.WSResponse)
  func websocketDidReceiveData(socket: KavenegarCall.WebSocket, data: Foundation.Data, response: KavenegarCall.WebSocket.WSResponse)
  func websocketHttpUpgrade(socket: KavenegarCall.WebSocket, request: Swift.String)
  func websocketHttpUpgrade(socket: KavenegarCall.WebSocket, response: Swift.String)
}
@objc open class WebSocket : ObjectiveC.NSObject, Foundation.StreamDelegate, KavenegarCall.WebSocketClient, KavenegarCall.WSStreamDelegate {
  public enum OpCode : Swift.UInt8 {
    case continueFrame
    case textFrame
    case binaryFrame
    case connectionClose
    case ping
    case pong
    public typealias RawValue = Swift.UInt8
    public init?(rawValue: Swift.UInt8)
    public var rawValue: Swift.UInt8 {
      get
    }
  }
  public static let ErrorDomain: Swift.String
  public var callbackQueue: Dispatch.DispatchQueue
  public class WSResponse {
    public var code: KavenegarCall.WebSocket.OpCode
    public var frameCount: Swift.Int
    public var buffer: Foundation.NSMutableData?
    final public let firstFrame: Foundation.Date
    @objc deinit
  }
  weak public var delegate: KavenegarCall.WebSocketDelegate?
  weak public var advancedDelegate: KavenegarCall.WebSocketAdvancedDelegate?
  weak public var pongDelegate: KavenegarCall.WebSocketPongDelegate?
  public var onConnect: (() -> Swift.Void)?
  public var onDisconnect: ((Swift.Error?) -> Swift.Void)?
  public var onText: ((Swift.String) -> Swift.Void)?
  public var onData: ((Foundation.Data) -> Swift.Void)?
  public var onPong: ((Foundation.Data?) -> Swift.Void)?
  public var onHttpResponseHeaders: (([Swift.String : Swift.String]) -> Swift.Void)?
  public var disableSSLCertValidation: Swift.Bool
  public var overrideTrustHostname: Swift.Bool
  public var desiredTrustHostname: Swift.String?
  public var sslClientCertificate: KavenegarCall.SSLClientCertificate?
  public var enableCompression: Swift.Bool
  public var security: KavenegarCall.SSLTrustValidator?
  public var enabledSSLCipherSuites: [Security.SSLCipherSuite]?
  public var isConnected: Swift.Bool {
    get
  }
  public var request: Foundation.URLRequest
  public var currentURL: Foundation.URL {
    get
  }
  public var respondToPingWithPong: Swift.Bool
  public init(request: Foundation.URLRequest, protocols: [Swift.String]? = nil, stream: KavenegarCall.WSStream = FoundationStream())
  convenience public init(url: Foundation.URL, protocols: [Swift.String]? = nil)
  convenience public init(url: Foundation.URL, writeQueueQOS: Foundation.QualityOfService, protocols: [Swift.String]? = nil)
  open func connect()
  open func disconnect(forceTimeout: Foundation.TimeInterval? = nil, closeCode: Swift.UInt16 = CloseCode.normal.rawValue)
  open func write(string: Swift.String, completion: (() -> ())? = nil)
  open func write(data: Foundation.Data, completion: (() -> ())? = nil)
  open func write(ping: Foundation.Data, completion: (() -> ())? = nil)
  open func write(pong: Foundation.Data, completion: (() -> ())? = nil)
  public func newBytesInStream()
  public func streamDidError(error: Swift.Error?)
  @objc deinit
  @objc override dynamic public init()
}
public enum CallFinishedReason : Swift.String {
  case hangup
  case unreachable
  case missed
  case rejected
  case callReceived
  case mediaConnectionBroken
  case messagingConnectionBroken
  case busy
  case unknown
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public protocol SSLTrustValidator {
  func isValid(_ trust: Security.SecTrust, domain: Swift.String?) -> Swift.Bool
}
open class SSLCert {
  public init(data: Foundation.Data)
  public init(key: Security.SecKey)
  @objc deinit
}
open class SSLSecurity : KavenegarCall.SSLTrustValidator {
  public var validatedDN: Swift.Bool
  public var validateEntireChain: Swift.Bool
  convenience public init(usePublicKeys: Swift.Bool = false)
  public init(certs: [KavenegarCall.SSLCert], usePublicKeys: Swift.Bool)
  open func isValid(_ trust: Security.SecTrust, domain: Swift.String?) -> Swift.Bool
  public func extractPublicKey(_ data: Foundation.Data) -> Security.SecKey?
  public func extractPublicKey(_ cert: Security.SecCertificate, policy: Security.SecPolicy) -> Security.SecKey?
  public func certificateChain(_ trust: Security.SecTrust) -> [Foundation.Data]
  public func publicKeyChain(_ trust: Security.SecTrust) -> [Security.SecKey]
  @objc deinit
}
public class Call {
  public var id: Swift.String
  public var direction: KavenegarCall.CallDirection
  public var caller: KavenegarCall.Endpoint
  public var receptor: KavenegarCall.Endpoint
  public var status: KavenegarCall.CallStatus
  public var delegate: KavenegarCall.CallDelegate
  public var callerMediaState: KavenegarCall.MediaState
  public var receptorMediaState: KavenegarCall.MediaState
  public var messaging: KavenegarCall.Messaging
  public var media: KavenegarCall.PeerConnectionWrapper?
  public var startedAt: Foundation.Date?
  public var finishedAt: Foundation.Date?
  public var onMediaStateChanged: ((KavenegarCall.PeerConnectionStateChangedEvent) -> Swift.Void)?
  public var onMessagingStateChanged: ((KavenegarCall.MessagingStateChangedEvent) -> Swift.Void)? {
    get
    set(newValue)
  }
  weak public var timer: Foundation.Timer?
  public var _duration: Swift.Int
  public var finishReason: KavenegarCall.CallFinishedReason?
  public var duration: Swift.Int {
    get
  }
  public init(id: Swift.String, status: KavenegarCall.CallStatus, direction: KavenegarCall.CallDirection, caller: KavenegarCall.Endpoint, receptor: KavenegarCall.Endpoint, messaging: KavenegarCall.Messaging, delegate: KavenegarCall.CallDelegate)
  public func initMedia()
  public func accept() throws
  public func start(sdp: Swift.String) throws
  public func reject() throws
  public func hangup(reason: KavenegarCall.CallFinishedReason = .hangup) throws
  public func ringing() throws
  public func dispose()
  public func setStatus(status: KavenegarCall.CallStatus, isLocal: Swift.Bool)
  @objc deinit
}
public enum Environment : Swift.String {
  case production
  case development
  case test
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public class KavenegarCall {
  public static var instance: KavenegarCall.KavenegarCall!
  final public let logger: KavenegarCall.Logger
  public static func initialize(environment: KavenegarCall.Environment = .production, logger: KavenegarCall.Logger = Logger())
  public func initCall(callId: Swift.String, accessToken: Swift.String, delegate: KavenegarCall.CallDelegate, callback: @escaping (KavenegarCall.JoinStatus, KavenegarCall.Call?) -> Swift.Void)
  @objc deinit
}
public let ErrorDomain: Swift.String
public let ErrorUnsupportedType: Swift.Int
public let ErrorIndexOutOfBounds: Swift.Int
public let ErrorWrongType: Swift.Int
public let ErrorNotExist: Swift.Int
public let ErrorInvalidJSON: Swift.Int
public enum Type : Swift.Int {
  case number
  case string
  case bool
  case array
  case dictionary
  case null
  case unknown
  public typealias RawValue = Swift.Int
  public init?(rawValue: Swift.Int)
  public var rawValue: Swift.Int {
    get
  }
}
public struct JSON {
  public init(data: Foundation.Data, options opt: Foundation.JSONSerialization.ReadingOptions = .allowFragments, error: Foundation.NSErrorPointer = nil)
  public init(_ object: Any)
  public init(parseJSON jsonString: Swift.String)
  public static func parse(_ json: Swift.String) -> KavenegarCall.JSON
  mutating public func merge(with other: KavenegarCall.JSON) throws
  public func merged(with other: KavenegarCall.JSON) throws -> KavenegarCall.JSON
  public var object: Any {
    get
    set
  }
  public var type: KavenegarCall.Type {
    get
  }
  public var error: Foundation.NSError? {
    get
  }
  @available(*, unavailable, renamed: "null")
  public static var nullJSON: KavenegarCall.JSON {
    get
  }
  public static var null: KavenegarCall.JSON {
    get
  }
}
public enum Index<T> : Swift.Comparable {
  case array(Swift.Int)
  case dictionary(Swift.DictionaryIndex<Swift.String, T>)
  case null
  public static func == (lhs: KavenegarCall.Index<T>, rhs: KavenegarCall.Index<T>) -> Swift.Bool
  public static func < (lhs: KavenegarCall.Index<T>, rhs: KavenegarCall.Index<T>) -> Swift.Bool
}
public typealias JSONIndex = KavenegarCall.Index<KavenegarCall.JSON>
public typealias JSONRawIndex = KavenegarCall.Index<Any>
extension JSON : Swift.Collection {
  public typealias Index = KavenegarCall.JSONRawIndex
  public var startIndex: KavenegarCall.JSON.Index {
    get
  }
  public var endIndex: KavenegarCall.JSON.Index {
    get
  }
  public func index(after i: KavenegarCall.JSON.Index) -> KavenegarCall.JSON.Index
  public subscript(position: KavenegarCall.JSON.Index) -> (Swift.String, KavenegarCall.JSON) {
    get
  }
  public typealias Element = (Swift.String, KavenegarCall.JSON)
  public typealias Iterator = Swift.IndexingIterator<KavenegarCall.JSON>
  public typealias SubSequence = Swift.Slice<KavenegarCall.JSON>
  public typealias Indices = Swift.DefaultIndices<KavenegarCall.JSON>
}
public enum JSONKey {
  case index(Swift.Int)
  case key(Swift.String)
}
public protocol JSONSubscriptType {
  var jsonKey: KavenegarCall.JSONKey { get }
}
extension Int : KavenegarCall.JSONSubscriptType {
  public var jsonKey: KavenegarCall.JSONKey {
    get
  }
}
extension String : KavenegarCall.JSONSubscriptType {
  public var jsonKey: KavenegarCall.JSONKey {
    get
  }
}
extension JSON {
  public subscript(path: [KavenegarCall.JSONSubscriptType]) -> KavenegarCall.JSON {
    get
    set
  }
  public subscript(path: KavenegarCall.JSONSubscriptType...) -> KavenegarCall.JSON {
    get
    set
  }
}
extension JSON : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral value: Swift.StringLiteralType)
  public init(extendedGraphemeClusterLiteral value: Swift.StringLiteralType)
  public init(unicodeScalarLiteral value: Swift.StringLiteralType)
  public typealias StringLiteralType = Swift.StringLiteralType
  public typealias ExtendedGraphemeClusterLiteralType = Swift.StringLiteralType
  public typealias UnicodeScalarLiteralType = Swift.StringLiteralType
}
extension JSON : Swift.ExpressibleByIntegerLiteral {
  public init(integerLiteral value: Swift.IntegerLiteralType)
  public typealias IntegerLiteralType = Swift.IntegerLiteralType
}
extension JSON : Swift.ExpressibleByBooleanLiteral {
  public init(booleanLiteral value: Swift.BooleanLiteralType)
  public typealias BooleanLiteralType = Swift.BooleanLiteralType
}
extension JSON : Swift.ExpressibleByFloatLiteral {
  public init(floatLiteral value: Swift.FloatLiteralType)
  public typealias FloatLiteralType = Swift.FloatLiteralType
}
extension JSON : Swift.ExpressibleByDictionaryLiteral {
  public init(dictionaryLiteral elements: (Swift.String, Any)...)
  public init(dictionaryLiteral elements: [(Swift.String, Any)])
  public typealias Key = Swift.String
  public typealias Value = Any
}
extension JSON : Swift.ExpressibleByArrayLiteral {
  public init(arrayLiteral elements: Any...)
  public typealias ArrayLiteralElement = Any
}
extension JSON : Swift.ExpressibleByNilLiteral {
  @available(*, deprecated, message: "use JSON.null instead. Will be removed in future versions")
  public init(nilLiteral: ())
}
extension JSON : Swift.RawRepresentable {
  public init?(rawValue: Any)
  public var rawValue: Any {
    get
  }
  public func rawData(options opt: Foundation.JSONSerialization.WritingOptions = JSONSerialization.WritingOptions(rawValue: 0)) throws -> Foundation.Data
  public func rawString(_ encoding: Swift.String.Encoding = .utf8, options opt: Foundation.JSONSerialization.WritingOptions = .prettyPrinted) -> Swift.String?
  public func rawString(_ options: [KavenegarCall.writtingOptionsKeys : Any]) -> Swift.String?
  public typealias RawValue = Any
}
extension JSON : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension JSON {
  public var array: [KavenegarCall.JSON]? {
    get
  }
  public var arrayValue: [KavenegarCall.JSON] {
    get
  }
  public var arrayObject: [Any]? {
    get
    set
  }
}
extension JSON {
  public var dictionary: [Swift.String : KavenegarCall.JSON]? {
    get
  }
  public var dictionaryValue: [Swift.String : KavenegarCall.JSON] {
    get
  }
  public var dictionaryObject: [Swift.String : Any]? {
    get
    set
  }
}
extension JSON {
  public var bool: Swift.Bool? {
    get
    set
  }
  public var boolValue: Swift.Bool {
    get
    set
  }
}
extension JSON {
  public var string: Swift.String? {
    get
    set
  }
  public var stringValue: Swift.String {
    get
    set
  }
}
extension JSON {
  public var number: Foundation.NSNumber? {
    get
    set
  }
  public var numberValue: Foundation.NSNumber {
    get
    set
  }
}
extension JSON {
  public var null: Foundation.NSNull? {
    get
    set
  }
  public func exists() -> Swift.Bool
}
extension JSON {
  public var url: Foundation.URL? {
    get
    set
  }
}
extension JSON {
  public var double: Swift.Double? {
    get
    set
  }
  public var doubleValue: Swift.Double {
    get
    set
  }
  public var float: Swift.Float? {
    get
    set
  }
  public var floatValue: Swift.Float {
    get
    set
  }
  public var int: Swift.Int? {
    get
    set
  }
  public var intValue: Swift.Int {
    get
    set
  }
  public var uInt: Swift.UInt? {
    get
    set
  }
  public var uIntValue: Swift.UInt {
    get
    set
  }
  public var int8: Swift.Int8? {
    get
    set
  }
  public var int8Value: Swift.Int8 {
    get
    set
  }
  public var uInt8: Swift.UInt8? {
    get
    set
  }
  public var uInt8Value: Swift.UInt8 {
    get
    set
  }
  public var int16: Swift.Int16? {
    get
    set
  }
  public var int16Value: Swift.Int16 {
    get
    set
  }
  public var uInt16: Swift.UInt16? {
    get
    set
  }
  public var uInt16Value: Swift.UInt16 {
    get
    set
  }
  public var int32: Swift.Int32? {
    get
    set
  }
  public var int32Value: Swift.Int32 {
    get
    set
  }
  public var uInt32: Swift.UInt32? {
    get
    set
  }
  public var uInt32Value: Swift.UInt32 {
    get
    set
  }
  public var int64: Swift.Int64? {
    get
    set
  }
  public var int64Value: Swift.Int64 {
    get
    set
  }
  public var uInt64: Swift.UInt64? {
    get
    set
  }
  public var uInt64Value: Swift.UInt64 {
    get
    set
  }
}
extension JSON : Swift.Comparable {
}
public func == (lhs: KavenegarCall.JSON, rhs: KavenegarCall.JSON) -> Swift.Bool
public func <= (lhs: KavenegarCall.JSON, rhs: KavenegarCall.JSON) -> Swift.Bool
public func >= (lhs: KavenegarCall.JSON, rhs: KavenegarCall.JSON) -> Swift.Bool
public func > (lhs: KavenegarCall.JSON, rhs: KavenegarCall.JSON) -> Swift.Bool
public func < (lhs: KavenegarCall.JSON, rhs: KavenegarCall.JSON) -> Swift.Bool
public enum writtingOptionsKeys {
  case jsonSerialization
  case castNilToNSNull
  case maxObjextDepth
  case encoding
  public static func == (a: KavenegarCall.writtingOptionsKeys, b: KavenegarCall.writtingOptionsKeys) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public class BaseRequest {
  @objc deinit
}
public enum MediaState : Swift.String {
  case connected
  case disconnected
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public enum LogLevel : Swift.String {
  case verbose
  case debug
  case info
  case warn
  case error
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
open class Logger {
  public init(level: KavenegarCall.LogLevel = .info)
  public var dateFormatter: Foundation.DateFormatter {
    get
  }
  open func log(message: Swift.String, level: KavenegarCall.LogLevel, fileName: Swift.String, funcName: Swift.String, line: Swift.Int)
  public func info(_ message: Swift.String, fileName: Swift.String = #file, funcName: Swift.String = #function, line: Swift.Int = #line)
  public func warn(_ message: Swift.String, fileName: Swift.String = #file, funcName: Swift.String = #function, line: Swift.Int = #line)
  public func debug(_ message: Swift.String, fileName: Swift.String = #file, funcName: Swift.String = #function, line: Swift.Int = #line)
  public func error(_ message: Swift.String, fileName: Swift.String = #file, funcName: Swift.String = #function, line: Swift.Int = #line)
  public func verbose(_ message: Swift.String, fileName: Swift.String = #file, funcName: Swift.String = #function, line: Swift.Int = #line)
  @objc deinit
}
public class Messaging {
  public var call: KavenegarCall.Call!
  public var onStateChanged: ((KavenegarCall.MessagingStateChangedEvent) -> Swift.Void)?
  public func start(accessToken: Swift.String, callID: Swift.String, callback: @escaping (KavenegarCall.JoinResponse) -> Swift.Void)
  public func close()
  @objc deinit
}
public class Endpoint {
  public var userName: Swift.String
  public var displayName: Swift.String
  public init(json: KavenegarCall.JSON)
  @objc deinit
}
public enum CallStatus : Swift.String {
  case new
  case trying
  case ringing
  case accepted
  case paused
  case conversation
  case finished
  case flushed
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public class MediaStateChangedEvent {
  final public let newState: KavenegarCall.MediaState
  final public let oldState: KavenegarCall.MediaState
  final public let role: KavenegarCall.EndpointRole
  public init(oldState: KavenegarCall.MediaState, newState: KavenegarCall.MediaState, role: KavenegarCall.EndpointRole)
  @objc deinit
}
public class KavenegarError : Swift.Error, Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
  @objc deinit
}
public class OfferResult {
  @objc deinit
}
public class MessagingStateChangedEvent {
  final public let oldState: KavenegarCall.MessagingStatus
  final public let newState: KavenegarCall.MessagingStatus
  @objc deinit
}
public enum JoinStatus : Swift.String {
  case success
  case accessDenied
  case invalidCall
  case callSessionFinished
  case sdkVersionNotSupported
  case failedToConnect
  case unknownError
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public struct SSLClientCertificateError : Foundation.LocalizedError {
  public var errorDescription: Swift.String?
}
public class SSLClientCertificate {
  convenience public init(pkcs12Path: Swift.String, password: Swift.String) throws
  public init(identity: Security.SecIdentity, identityCertificate: Security.SecCertificate)
  convenience public init(pkcs12Url: Foundation.URL, password: Swift.String) throws
  public init(pkcs12Url: Foundation.URL, importOptions: CoreFoundation.CFDictionary) throws
  @objc deinit
}
public class SilentLogger : KavenegarCall.Logger {
  override public func info(_ message: Swift.String, fileName: Swift.String = #file, funcName: Swift.String = #function, line: Swift.Int = #line)
  override public func debug(_ message: Swift.String, fileName: Swift.String = #file, funcName: Swift.String = #function, line: Swift.Int = #line)
  override public func verbose(_ message: Swift.String, fileName: Swift.String = #file, funcName: Swift.String = #function, line: Swift.Int = #line)
  override public func warn(_ message: Swift.String, fileName: Swift.String = #file, funcName: Swift.String = #function, line: Swift.Int = #line)
  override public func error(_ message: Swift.String, fileName: Swift.String = #file, funcName: Swift.String = #function, line: Swift.Int = #line)
  override public init(level: KavenegarCall.LogLevel = super)
  @objc deinit
}
public enum MessagingStatus : Swift.String {
  case initialized
  case disconnected
  case terminated
  case connected
  case joined
  case failed
  public typealias RawValue = Swift.String
  public init?(rawValue: Swift.String)
  public var rawValue: Swift.String {
    get
  }
}
public class JoinResponse : KavenegarCall.BaseRequest {
  public var result: KavenegarCall.JoinStatus!
  public var callId: Swift.String!
  public var direction: KavenegarCall.CallDirection?
  public var caller: KavenegarCall.Endpoint?
  public var receptor: KavenegarCall.Endpoint?
  public var status: KavenegarCall.CallStatus
  @objc deinit
}
extension KavenegarCall.SoundType : Swift.Equatable {}
extension KavenegarCall.SoundType : Swift.Hashable {}
extension KavenegarCall.EndpointRole : Swift.Equatable {}
extension KavenegarCall.EndpointRole : Swift.Hashable {}
extension KavenegarCall.EndpointRole : Swift.RawRepresentable {}
extension KavenegarCall.CallDirection : Swift.Equatable {}
extension KavenegarCall.CallDirection : Swift.Hashable {}
extension KavenegarCall.CallDirection : Swift.RawRepresentable {}
extension KavenegarCall.CloseCode : Swift.Equatable {}
extension KavenegarCall.CloseCode : Swift.Hashable {}
extension KavenegarCall.CloseCode : Swift.RawRepresentable {}
extension KavenegarCall.ErrorType : Swift.Equatable {}
extension KavenegarCall.ErrorType : Swift.Hashable {}
extension KavenegarCall.WebSocket.OpCode : Swift.Equatable {}
extension KavenegarCall.WebSocket.OpCode : Swift.Hashable {}
extension KavenegarCall.WebSocket.OpCode : Swift.RawRepresentable {}
extension KavenegarCall.CallFinishedReason : Swift.Equatable {}
extension KavenegarCall.CallFinishedReason : Swift.Hashable {}
extension KavenegarCall.CallFinishedReason : Swift.RawRepresentable {}
extension KavenegarCall.Environment : Swift.Equatable {}
extension KavenegarCall.Environment : Swift.Hashable {}
extension KavenegarCall.Environment : Swift.RawRepresentable {}
extension KavenegarCall.Type : Swift.Equatable {}
extension KavenegarCall.Type : Swift.Hashable {}
extension KavenegarCall.Type : Swift.RawRepresentable {}
extension KavenegarCall.writtingOptionsKeys : Swift.Equatable {}
extension KavenegarCall.writtingOptionsKeys : Swift.Hashable {}
extension KavenegarCall.MediaState : Swift.Equatable {}
extension KavenegarCall.MediaState : Swift.Hashable {}
extension KavenegarCall.MediaState : Swift.RawRepresentable {}
extension KavenegarCall.LogLevel : Swift.Equatable {}
extension KavenegarCall.LogLevel : Swift.Hashable {}
extension KavenegarCall.LogLevel : Swift.RawRepresentable {}
extension KavenegarCall.CallStatus : Swift.Hashable {}
extension KavenegarCall.CallStatus : Swift.RawRepresentable {}
extension KavenegarCall.JoinStatus : Swift.Hashable {}
extension KavenegarCall.JoinStatus : Swift.RawRepresentable {}
extension KavenegarCall.MessagingStatus : Swift.Hashable {}
extension KavenegarCall.MessagingStatus : Swift.RawRepresentable {}
